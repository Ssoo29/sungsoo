-- DAY10

-- DDL
-- 테이블 무결성 제약조건 (CONSTRANT)
-- NOT TIULL
-- 컬럼에 값이 무조건 기록되어야 할 때 사용
--웹엣의 필수입력항목
--컬럼 레벨에서 i

create table TESTNN(
  NNID NUMBER(5) NOT NULL, -- 컬럼 레벨
  NN_NAME VARCHAR2(20)
  );
  
  --값 기록테스트
  INSERT INTO TESTNN(NNID, NN_NAME)
  VALUES(NULL,NULL);
  --NNID에 NOT NULL ㅈ ㅔ약조건 위배됨.
  
  INSERT INTO TESTNN -- 컬럼명이 생략되면, 테이블의 모든 컬럼에 값을 기록
  VALUES(1, NULL); -- 테이블의 컬럼 생성 순서의 자료형 맞춰서 값 기록 나열함
  
  SELECT * FROM TESTNN;
  
  INSERT INTO TESTNN(NN_NAME)
  VALUES('ORACLE'); --생략된 컬럼은 자동 NULL처리이기 때문에 에러
  
  --테이블레벨의 예
  CREATE TABLE TESTNN2(
  NN_ID NUMBER(5) CONSTRAINT T2_NNID NOT NULL,
  NN_NAME VARCHAR2(10)--,
  --테이블레벨
  --CONSTRAINT 제약조건이름 제약조건종류 (적용할 컬럼명)
  --CONSTRAINT T2_NNNAME NOT NULL (NN_NAME)
  );
  
  
  -- 2.UNIQUE 제약조건
  -- 해당 컬럼의 중복값(같은값) 압력을 막겠다는 의미의 제약조건임
  -- 설정하면 같은 값은 두번 기록 못하는 컬럼이 됨
  -- 컬럼레벨, 테이블레벨 둘 다 설정할 수 있음
  -- 복합키로도 설정할 수 있음.
  
  CREATE TABLE TESTUN (
   UN_ID CHAR(3) UNIQUE,
   UN_NAME VARCHAR2(10) NOT NULL 
  );
  
  -- 기록 테스트
  INSERT INTO TESTUN VALUES ('AAA', 'ORACLE');
  INSERT INTO TESTUN VALUES ('AAA', 'JAVA'); --제약조건 위배됨
  INSERT INTO TESTUN VALUES ('AAB', 'JAVA');
  
  SELECT * FROM TESTUN;
  
  CREATE TABLE TESTUN2 (
    UN_ID CHAR(3) CONSTRAINT T2_UNID UNIQUE, 
    UN_NAME VARCHAR2(10) CONSTRAINT T2_UNNAME NOT NULL
  );
  
  CREATE TABLE TESTUN3 (
    UN_ID CHAR(3),
    UN_NAME VARCHAR2(10) NOT NULL,
    CONSTRAINT T3_UNID UNIQUE (UN_ID)
  );
  
  
  --3. PRIMARY KEY
  --테이블에서 한 방의 정보를 찾기위해 쓸 수 있는 값이 기록된 컬럼에 적용함.
  --NOT NULL + UNIQUE
  --한 테이블에 한번만 사용할 수 있음.
  
  CREATE TABLE TESTPK (
    PK_ID NUMBER PRIMARY KEY,
    PK_NAME VARCHAR2(15) NOT NULL,
    PK_DATE DATE
  );
  
  --기록 테스트
  INSERT INTO TESTPK VALUES(1, '홍길동', '15/03/12');
  INSERT INTO TESTPK VALUES(NULL, '박문수', SYSDATE); -- 에러 : NOT NULL 제약조건 위배
  INSERT INTO TESTPK VALUES(1, '박문수', SYSDATE); -- 에러: UNIQUE 제약조건 위배됨
  INSERT INTO TESTPK VALUES(2, '박문수', SYSDATE);
  
  SELECT * FROM TESTPK;
  
  --테이블당 한 번만 설정할 수 있음
  CREATE TABLE TESTPK2(
    PID NUMBER PRIMARY KEY,
    PNAME VARCHAR2(15) PRIMARY KEY
    --ERROR
  );
  
  CREATE TABLE TESTPK2(
   PID NUMBER CONSTRAINT P2_PID PRIMARY KEY,
   PNAME VARCHAR2(15), 
   PDATE DATE
  );
  
  
  CREATE TABLE TESTPK3(
    PID NUMBER,
    PNAME VARCHAR2(15),
    PDATE DATE, 
    CONSTRAINT T3_PID PRIMARY KEY(PID)
  );
  
  
  --4. CHECL
  --컬럼에 기록되는 값에 대한 조건 설정을 하는 제약 조건
  --CHECK (컬럼명 연산자 비교값)
  --비교값은 고정값이어야 함. 바뀌는 값이면 에러남.
  CREATE TABLE TESTPK4(
    C_NAME VARCHAR2(15) CONSTRAINT TOK_NAME NOT NULL,
    C_PRICE NUMBER(5) CHECK (C_PRICE BETWEEN 1 AND 99999),
    C_LEVEL CHAR(1) CHECK (C_LEVEL IN ('A', 'B', 'C'))
  );
  
  INSERT INTO TESTPK4 VALUES('겔럭시 S9', 65000, 'A');
  INSERT INTO TESTPK4 VALUES('LG L7', 125000, 'A'); --ERROR : CHECH 제약조건 위배됨
  INSERT INTO TESTPK4 VALUES('LG G7', '0', 'A'); --ERROR
  INSERT INTO TESTPK4 VALUES('LG G7', 65300, 'D'); --ERROR :CHECK 제약조건
  
  SELECT * FROM TESTPK4;

  
  CREATE TABLE CONSTRAINT_EMP
  (EID    CHAR(3) CONSTRAINT PKEID PRIMARY KEY,
   ENAME  VARCHAR2(20) CONSTRAINT NENAME NOT NULL,
   ENO    CHAR(14) CONSTRAINT NENO NOT NULL CONSTRAINT UENO UNIQUE,
   EMAIL  VARCHAR2(25) CONSTRAINT UEMAIL UNIQUE,
   PHONE  VARCHAR2(12),
   HIRE_DATE DATE DEFAULT SYSDATE,
   JID    CHAR(2) CONSTRAINT FKJID REFERENCES JOB ON DELETE SET NULL,
   SALARY NUMBER,
   BONUS_PCT NUMBER,
   MARRIAGE CHAR(1) DEFAULT 'N' CONSTRAINT CHK CHECK (MARRIAGE IN ('Y', 'N')),
   MID      CHAR(3) CONSTRAINT FKMID REFERENCES CONSTRAINT_EMP ON DELETE SET NULL,
   DID      CHAR(2),
   CONSTRAINT FKDID FOREIGN KEY (DID) REFERENCES DEPARTMENT ON DELETE CASCADE
   );
  
  
  CREATE TABLE TESTCHK2 (
    C_NAME VARCHAR2(15) PRIMARY KEY,
    C_PRICE NUMBER(5) CHECK(C_PRICE >= 1 AND C_PRICE <= 99999),
    C_LEVEL CHAR(1) CHECK (C_LEVEL = 'A' OR C_LEVEL = 'B' OR C_LEVEL = 'C'),
    --C_DATE DATE CHECK (C_DATE < SYSDATE),
    --비교값은 반드시 리터럴(값) 사용, 바뀌는 값은 사용 못함
    C_DATE DATE CHECK(C_DATE < TO_DATE('16/01/01', 'YYYY/MM/DD')) --DEVELOPER 버그
  );

--5. FOREIGN KEY
--외래키, 외부키
--다른 테이블에서 제공하는 값만 사용할 수 있는 컬럼
--제공되지 않는 값 사용하면 에러남

--컬럼레벨에서 설정
--[CONSTRAINT 이름] REFERENCES 참조테이블명 [(참조할 컬럼명)]
--테이블레벨에서 설정
--[CONSTRAINT 이름] FOREIGN KEY (적용할 컬럼명) REFERENCES 참조테이블 [(참조할컬럼명)]
--NULL은 사용할 수 있음
  CREATE TABLE TESTFK(
    EMP_ID CHAR(3) REFERENCES EMPLOYEE, --참조 컬럼명이 생략되면 PRIMARY KEY 컬럼이 자동 연결
    DEPT_ID CHAR(2) CONSTRAINT TFK_DID REFERENCES DEPARTMENT (DEPT_ID),
    JOB_ID CHAR(2),
        --테이블레벨
        CONSTRAINT TFK_JID FOREIGN KEY (JOB_ID) REFERENCES JOB (JOB_ID)
  );
  --기록 테스트
  --연결된 테이블에 연결된 컬럼에 기록되어있는 값만 사용할 수 있음.
  INSERT INTO TESTFK VALUES('300', NULL, NULL); --제공되지 않는 값 사용, 에러
  INSERT INTO TESTFK VALUES('100', NULL, NULL);
  INSERT INTO TESTFK VALUES('200', '70', NULL);
  INSERT INTO TESTFK VALUES('200', '90', NULL);
  INSERT INTO TESTFK VALUES('200', '90', 'J10');
  INSERT INTO TESTFK VALUES('200', '90', 'J7');
  
  SELECT * FROM TESTFK;
  
  --외래키 제약조건에서 PARENT KEY가 될 수 있는 컬럼은
  --PRIMARY KEY 또는 UNIQUE KEY 제약조건이 설정된 컬럼만 참조컬럼이 될 수 있음.
  CREATE TABLE NOPK(
  ID CHAR(3),
  NAME VARCHAR2(10)
  );
  
  CREATE TABLE TESTFKK2(
    FID CHAR(3) REFERENCES NOPK (ID),
    FNAME VARCHAR2(10)
 ); 
 
 CREATE TABLE TSETUN5 (
    ID CHAR(3) UNIQUE,
    NAME VARCHAR2(10)
 );
 
  CREATE TABLE TESTFKK2(
    FID CHAR(3) REFERENCES TSETUN5(ID),
    FNAME VARCHAR2(10)
 ); 
  
--복합키 설정 관련
--여러 개의 컬럼을 묶어서 UNIQUE 제약조건이나 PRIMARY KEY 제약조건을
--설정한 복합키를 참조할 경우
CREATE TABLE TEST_COMPLEX(
    ID NUMBER,
    NAME VARCHAR2(10),
    UNIQUE (ID, NAME)
);

INSERT INTO TEST_COMPLEX VALUES (100, 'ORACLE');
INSERT INTO TEST_COMPLEX VALUES (NULL, NULL);
INSERT INTO TEST_COMPLEX VALUES (100, 'JAVA'); --복합키로 묶었기 때문에 (ID,NAME) 한세트여서 UNIQUE 중복 안걸림
INSERT INTO TEST_COMPLEX VALUES (NULL, NULL);
INSERT INTO TEST_COMPLEX VALUES (NULL, 'JAVA');
INSERT INTO TEST_COMPLEX VALUES (NULL, 'JAVA');-- 중복에러 


SELECT * FROM TEST_COMPLEX;

 --복합키를 참조키로 설정할 경우
 CREATE TABLE TESTFK4 (
  ID NUMBER,
  NAME VARCHAR2(10),
  PRICE NUMBER,
  FOREIGN KEY (ID, NAME) REFERENCES TEST_COMPLEX (ID, NAME) 
 );
 
CREATE TABLE TESTFK5 (
  ID NUMBER REFERENCES TEST_COMPLEX (ID),
  NAME VARCHAR2(10) REFERENCES TEST_COMPLEX (NAME),
  PRICE NUMBER--,
  --FOREIGN KEY (ID) REFERENCES TEST_COMPLEX (ID, NAME) 
 );--에ㅡㅡ러
 
 --외래키가 설정된 커럶에 값이 사용 중이면, 부모키는 절대 삭제 할 수 없음.
 DELETE FROM DEPARTMENT
 WHERE DEPT_ID = '90';
 --EMPLOYEE 테이블에 DEPT_ID 컬럼에 '90'이 사용되고 있음 : CHILD RECORD
 
 --FOREIGN KEY 제약조건 설정시 삭제옵션을 추가할 수 있음: DELETION OPTION
 --기본은 자식레코드가 존재하면 부모키는 삭제 불가능임 (RESTRICTED)
 --ON DELETE SET NULL, ON DELETE CASCADE
 
 --ON DELETE SET NULL 추가
 --부모키가 삭제될 때 자식 레코드 값을 NULL로 바꿈
 CREATE TABLE PRODUCT_STATE(   --부모
    PSTATE CHAR(1) PRIMARY KEY,
    PCOMMENT VARCHAR2(10)
 );

INSERT INTO PRODUCT_STATE VALUES ('A', '최고급');
INSERT INTO PRODUCT_STATE VALUES ('B', '보통');
INSERT INTO PRODUCT_STATE VALUES ('C', '저급');

SELECT * FROM PRODUCT_STATE;

CREATE TABLE PRODUCT (       --자식
 PNAME VARCHAR2(20) PRIMARY KEY,
 PPRICE NUMBER CHECK (PPRICE > 0),
 PSTATE CHAR(1) REFERENCES PRODUCT_STATE ON DELETE SET NULL
);

INSERT INTO PRODUCT VALUES ('겔럭시', 653000, 'A');
INSERT INTO PRODUCT VALUES ('G7', 740000, 'B');
INSERT INTO PRODUCT VALUES ('맥북', 2500000, 'C');


SELECT * FROM PRODUCT;

--삭제 테스트
DELETE FROM PRODUCT_STATE
WHERE PSTATE = 'A';

COMMIT;

SELECT * FROM PRODUCT;
SELECT * FROM PRODUCT_STATE;

--ON DELETE CASCADE
--제공되는 부모키가 삭제되면, 제공값을 사용하는 자식 레코드도 함께 삭제됨
CREATE TABLE PRODUCT2(
 PNAME VARCHAR2(20) PRIMARY KEY,
 PPRICE NUMBER,
 PSTATE CHAR(1) REFERENCES PRODUCT_STATE (PSTATE) ON DELETE CASCADE
 );
 
INSERT INTO PRODUCT2 VALUES ('맥북', 2500000, 'B');
INSERT INTO PRODUCT2 VALUES ('맥에어', 1250000, 'C');

SELECT * FROM PRODUCT2;

-- 부모키 삭제
DELETE FROM PRODUCT_STATE
WHERE PSTATE = 'B';

COMMIT;

SELECT * FROM PRODUCT_STATE;
SELECT * FROM PRODUCT2;
 
 CREATE TABLE TABLE_SUBQUERY1
AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_NAME, JOB_TITLE
       FROM EMPLOYEE
       LEFT JOIN DEPARTMENT USING(DEPT_ID)
       LEFT JOIN JOB USING (JOB_ID);

SELECT * FROM TABLE_SUBQUERY1;

--DESCRIBE 테이블명;
--DESC 테이블명;
--테이블의 구조를 확인하는 명령어
DESC TABLE_SUBQUERY1; 
  
--직원 테이블에서 90번 부서에 소속된 직원 정보만 따로 EMP_COPY90 테이블에 저장
CREATE TABLE EMP_COPY90
AS SELECT *
    FROM EMPLOYEE
    WHERE DEPT_ID = '90';
  
SELECT * FROM EMP_COPY90;

--복사본 테이블 만들기
CREATE TABLE EMP_COPY
AS SELECT * FROM EMPLOYEE;

SELECT * FROM EMP_COPY;

DESC EMP_COPY;

--서브쿼리를 이용해서 기존 테이블을 복사할 경우,
--컬럼명, 자료형, NOT NULL 제약조건, 값은 그대로 복사됨.
--나머지 제약조건들은 복사되지 않음.

--제약조건 관련 데이터딕셔너리 확인
--USER_CONSTRAINTS
SELECT * FROM USER_CONSTRAINTS;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP_COPY';


--실습 1
--사번, 이름, 급여, 직급명, 부서명, 근무지역명, 소속국가명 조회
--조회 결과를 EMN_LIST 테이블에 저장함
CREATE TABLE EMN_LIST
AS SELECT EMP_ID, EMP_NAME, SALARY, JOB_TITLE, DEPT_NAME, COUNTRY_NAME
    FROM EMPLOYEE
    JOIN JOB USING(JOB_ID)
    JOIN DEPARTMENT USING(DEPT_ID)
    JOIN LOCATION ON (LOC_ID = LOCATION_ID)
    JOIN COUNTRY USING (COUNTRY_ID);

SELECT *  FROM EMN_LIST;
--실습 2
--EMPLOYEE 테이블에서 남자 직원의 정보만 조회해서
--EMP_MAN 테이블에 저장함.
CREATE TABLE EMP_MAN
AS SELECT * 
   FROM EMPLOYEE
   WHERE SUBSTR(EMP_NO, 8, 1) = '1';
   
 SELECT *  FROM EMP_MAN;  
--실습 3
--여자 직원의 정보만 조회해서, EMP_FEMAIL 테이블에 저장함.

CREATE TABLE EMP_FEMAIL
AS SELECT *
   FROM EMPLOYEE
   WHERE SUBSTR(EMP_NO, 8, 1) = '2';

--실습 4
--부서별 직원 명단을 정리해서 PART_LIST 테이블에 저장함
--DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID로 컬럼 구성함


CREATE TABLE PART_LIST
AS SELECT DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID
   FROM EMPLOYEE
   LEFT JOIN JOB USING(JOB_ID)
   LEFT JOIN DEPARTMENT USING(DEPT_ID)
   ORDER BY DEPT_ID;
   
  
 COMMENT ON COLUMN PART_LIST.DEPT_NAME IS '부서명';
 COMMENT ON COLUMN PART_LIST.JOB_TITLE IS '직급명';
 COMMENT ON COLUMN PART_LIST.EMP_NAME IS '직원명';
 COMMENT ON COLUMN PART_LIST.EMP_ID IS '사번';

-- 실습 : 제약조건이 설정된 테이블 만들기
-- 테이블명 : PHONEBOOK
-- 컬럼명 :  ID  CHAR(3) 기본키(저장이름 : PK_PBID)
--         PNAME      VARCHAR2(20)  널 사용못함.
--                                 (NN_PBNAME) 
--         PHONE      VARCHAR2(15)  널 사용못함
--                                 (NN_PBPHONE)
--                                 중복값 입력못함
--                                 (UN_PBPHONE)
--         ADDRESS    VARCHAR2(100) 기본값 지정함
--                                 '서울시 구로구'

-- NOT NULL을 제외하고, 모두 테이블 레벨에서 지정함.

CREATE TABLE PHONEBOOK(
 ID CHAR(3),
 PNAME VARCHAR2(20) CONSTRAINT NN_PBNAME NOT NULL,
 PHONE VARCHAR2(15) CONSTRAINT NN_PBPHONE NOT NULL,
 ADDRESS VARCHAR2(100) DEFAULT '서울시 구로구',
 CONSTRAINT PK_PBID PRIMARY KEY (ID),
 CONSTRAINT UN_PBPHONE UNIQUE (PHONE)
);

INSERT INTO PHONEBOOK
VALUES('A01', '홍길동', '010-1234-5678', DEFAULT);
 
 SELECT * FROM PHONEBOOK;
